<?php 
/* 
 *  Role 控制器服务层
 *  @author wuchuheng
 *  @data 2019/05/16
 *  @email wuchuheng@163.com
 *  @blog  www.wuchuheng.com
 */
namespace app\api\service;

use app\api\model\Member; 
use app\api\service\Base;
use think\Db;
use think\facade\Request;
use app\api\model\MemberGroup;

class Role extends Base
{
    /**
     * 获取客服组数据树
     * @return obj
     */
    public function getAllUser()
    {
        $count           = Member::count();
        $count_no_count  = (new Member())->countNotBelong();
        $memberGroup     = (new MemberGroup())->getGroup();
        $otherNode       = [
            'title'     => "未分组({$count_no_count})",
            'id'        => -1,
            'parentId'  => 0-1
          ];
        $subNode = $this->_arrToTree($memberGroup->toArray());
        $subNode[] = $otherNode; 
        $data[] = [
          'title'    => "所有({$count})",
          'id'       => 0,
          'spread'   => true,
          'parentId' => 0,
          'children' => $subNode
        ];
        return $data;
    } 


    /**
     * 添加客服组
     * @return  boolean    处理结果
     */
    public function AddGroup() 
    {
        $data['name'] = Request::param('nodeName');
        $pid = Request::param('parentId');
        $parentNode =(new MemberGroup())->where("id = {$pid}")->field('id,path')->find();
        $data['path'] = $parentNode->path . '-' . $parentNode->id;
        $data['pid']  = $parentNode->id;
        $data['name'] = Request::param('addNodeName');
        $isSave = (new MemberGroup())->save($data);
        return $isSave;
    }

    /**
     * 将数组遍历为数组树 
     * @arr     有子节点的目录树
     * @tree    遍历赋值的树
     * @return  array   
     *
     */ 
    protected function _arrToTree($arr, $tree = [])
    {
      do{
        $ele = reset($arr); 
        array_shift($arr);
        $node['id'] = $ele['id'];
        $node['title'] = $ele['title'] . "(" . $ele['count'] . ")";
        $node['parentId'] = $ele['pid'];
        $node['parentId'] = $ele['pid'];
        if (isset($arr[0]['fullpath']) && $arr[0]['fullpath'] !== '0-0') {
          $node['children'] = $this->_arrToTree($arr);
        }
        if ($node['fullpath'] !== '0-0' )  return $node;
        $isnext = isset($arr[0]) && $arr[0]['fullpath'] == '0-0' ? true : false;
        $result[] = $node;
      } while ($isnext);
      return $result;
      //foreach($arr as $k=> $v) {
      //  if ($v['fullpath'] == '0-0') {
      //    array_shift($arr);
      //    $node['id'] = $v['id'];
      //    $node['title'] = $v['title'] . "(" . $v['count'] . ")";
      //    $node['parentId'] = $v['pid'];
      //    if (count($arr) === 0) return [$node];
      //    $nextNode = reset($arr);
      //    dump($arr);exit;
      //    if ($nextNode['fullpath'] !== '0-0') {
      //      $node['children'] = $this->_arrToTree($arr);
      //    }
      //    $result[] = $node;
      //  } else {
      //    array_shift($arr);
      //    $node['id'] = $v['id'];
      //    $node['title'] = $v['title'] . "(" . $v['count'] . ")";
      //    $node['parentId'] = $v['pid'];
      //    if (strpos($nextNode['fullpath'], $v['fullpath']) > 0) {
      //        $node['children'] = $this->_arrToTree($arr);
      //    }
      //    return $node; 
      //  } 
      //}
    }
  
}
